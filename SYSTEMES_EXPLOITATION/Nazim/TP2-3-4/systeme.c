#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <time.h>
#include "cpu.h"
#include "systeme.h"

int current_process = -1; /* num du processus courant  */

/**********************************************************
** Demarrage du systeme
***********************************************************/
static PSW systeme_init(void) {
	PSW cpu;

	printf("Booting.\n\n");
	/*** creation d'un programme ***/
	make_inst(0, INST_SUB, 2, 2, -1000); /* R2 -= R2-1000 */
	make_inst(1, INST_ADD, 1, 2, 500);   /* R1 += R2+500 */
	make_inst(2, INST_ADD, 0, 2, 200);   /* R0 += R2+200 */
	make_inst(3, INST_ADD, 0, 1, 100);   /* R0 += R1+100 */

	make_inst(4, INST_SYSC, 0, 0, SYSC_EXIT);
	
	/*** valeur initiale du PSW ***/
	memset (&cpu, 0, sizeof(cpu));
	cpu.PC = 0;
	cpu.SB = 0;
	cpu.SS = 20; // Valeur initiale : 20

	process[0].cpu = cpu;
	process[0].state = READY;
	current_process = 0;

	return cpu;
}

/**********************************************************
** Simulation du systeme (mode systeme)
***********************************************************/
PSW systeme(PSW m) {
	if(m.IN != INT_INIT)
		printf("-------------- SYSTEME(%d) --------------\n", m.IN);
	switch(m.IN) {
	    case INT_INIT:
	        return systeme_init();

	    case INT_SEGV:
	        printf("[INT_SEGV]\n\tPC : %d\n", m.PC);
	        exit(INT_SEGV);
	        break;

	    case INT_TRACE:
	        printf("[INT_TRACE]\n\tPC : %d\n\tDR :", m.PC);
	        int i; for(i=0; i<8; i++) {
	        	if(i > 0) printf("\t    ");
	        	printf(" DR[%d] = %d\n", i, m.DR[i]);
	        }
	        break;

	    case INT_INST:
	        printf("[INT_INST]\n\tPC : %d", m.PC);
	        exit(INT_INST);
	        break;

		case INT_CLOCK:
		printf("[INT_CLOCK]\n");
	        if(current_process != -1) process[current_process].cpu = m;
	        do {
	            current_process = (current_process + 1) % MAX_PROCESS;
	            if(process[current_process].state == SLEEP
	            		&& time(NULL) >= process[current_process].cpu.AC)
	                process[current_process].state = READY;
	        } while(process[current_process].state != READY);
	        m = process[current_process].cpu;
	        break;

	    case INT_SYSC:
	    	printf("[INT_SYSC]\n\tPC : %d", m.PC);
	    	break;

	    case SYSC_PUTI:
	        printf("[SYSC_PUTI]\n\tProcess : %d\n\tRI.i : %d\n\tDR : %d\n",
	        	current_process, m.RI.i, m.DR[m.RI.i]);
	        break;

	    case SYSC_NEW_THREAD:
			int childId = 0;
			do childId = (1+childId)%MAX_PROCESS;
				while(process[childId].state = EMPTY);
			m.DR[m.RI.i] = childId;			
			m.AC = childId;
			process[childId].cpu = m;
			process[childId].state = READY;
			process[childId].cpu.DR[m.RI.i] = 0;
			process[childId].cpu.AC = 0;
			process[childId].cpu.PC = m.PC + 1;
    		break;

    	case SYSC_SLEEP:
			process[current_process].state = SLEEP;
			m.AC = m.DR[m.RI.i] + time(NULL);
			break;

	    case SYSC_EXIT:
	        printf("Fin normale de la machine\n");
	        exit(0);

	    default:
	        break;
	}
    
    printf("\n");
    return m;
}