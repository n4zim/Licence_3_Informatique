#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include "cpu.h"

/**********************************************************
** definition de la memoire simulee
***********************************************************/
WORD mem[128];     /* memoire                       */

/**********************************************************
** Placer une instruction en memoire
***********************************************************/
void make_inst(int adr, unsigned code, unsigned i, unsigned j, short arg) {
	union { WORD word; INST fields; } inst;
	inst.fields.OP  = code;
	inst.fields.i   = i;
	inst.fields.j   = j;
	inst.fields.ARG = arg;
	mem[adr] = inst.word;
}

INST decode_instruction(WORD value) {
	union { WORD integer; INST instruction; } inst;
	inst.integer = value;
	return inst.instruction;
}

/**********************************************************
** instruction d'addition
***********************************************************/
PSW cpu_ADD(PSW m) {
	m.AC = m.DR[m.RI.i] += (m.DR[m.RI.j] + m.RI.ARG);
	m.PC += 1;
	return m;
}

/**********************************************************
** instruction de soustraction
***********************************************************/
PSW cpu_SUB(PSW m) {
	m.AC = m.DR[m.RI.i] -= (m.DR[m.RI.j] + m.RI.ARG);
	m.PC += 1;
	return m;
}

/**********************************************************
** instruction de comparaison
***********************************************************/
PSW cpu_CMP(PSW m) {
	m.AC = (m.DR[m.RI.i] - (m.DR[m.RI.j] + m.RI.ARG));
	m.PC += 1;
	return m;
}

PSW cpu_IFGT(PSW m) {
	if(m.AC > 0) m.PC = m.RI.ARG;
		else m.PC++;
	return m;
}

PSW cpu_SYSC(PSW m) {
	m.IN = m.RI.ARG; // TODO : refaire
	m.PC++;
	return m;
}

/**********************************************************
** instuction de stockage
***********************************************************/
PSW cpu_STORE(PSW m) {
	m.AC = m.DR[m.RI.j] + m.RI.ARG;
	if((m.AC > m.SS) || (m.AC < 0)) {
		m.IN = INT_SEGV;
	} else {
		mem[m.SB+m.AC] = m.DR[m.RI.i];
		m.AC = m.DR[m.RI.i];
		m.PC += 1;
	}
	return m;
}

/**********************************************************
** instruction de calcul pour l'allocation de taille
***********************************************************/
PSW cpu_LOAD(PSW m) {
	m.AC = m.DR[m.RI.j] + m.RI.ARG;
	if(m.AC > m.SS || m.AC < 0) m.IN = INT_SEGV;
		else {
			m.AC = mem[m.SB + m.AC];
			m.DR[m.RI.i] = m.AC;
			m.PC += 1;
		}
	return m;
}

/**********************************************************
** Simulation de la CPU (mode utilisateur)
***********************************************************/
PSW cpu(PSW m) {
	/*** lecture et decodage de l'instruction ***/
	if (m.PC < 0 || m.PC >= m.SS) {
		m.IN = INT_SEGV;
		return (m);
	}
	m.RI = decode_instruction(mem[m.PC + m.SB]);
	
	/*** execution de l'instruction ***/
	switch (m.RI.OP) {
		case INST_ADD: m = cpu_ADD(m); break;
		
		case INST_SUB: m = cpu_SUB(m); break;
		
		case INST_CMP: m = cpu_CMP(m); break;

		case INST_IFGT: m = cpu_IFGT(m); break;

    	case INST_NOP: ++m.PC; break;

    	case INST_JUMP: m.PC = m.RI.ARG; break;

    	case INST_HALT: break;

    	case INST_SYSC: m = cpu_SYSC(m); return m;

    	case INST_LOAD m = cpu_LOAD(m); break;

    	case INST_STORE: m = cpu_STORE(m); return m;
		
		default: /*** interruption instruction inconnue ***/
			m.IN = INT_INST;
			return (m);
	}

	/*** interruption apres chaque instruction ***/
	m.IN = INT_TRACE;
	return m;
}