
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#include "cpu.h"
#include "systeme.h"

time_t sleep_time[MAX_PROCESS];
time_t t;
int getchar_count = 0;
char tampon = '\0';

/**********************************************************
** Demarrage du systeme
***********************************************************/

static PSW systeme_init(void) {
	t = time(&t);
	int j;
	for(j=0;j<MAX_PROCESS;j++)
		process[j].state = EMPTY;
	current_process = 0;
	process[current_process].state = READY;
	int i=0;
	/*** creation d'un programme ***/
	/*make_inst(i++, INST_SUB, 1, 1, 0); 
	make_inst(i++, INST_SUB, 2, 2, -1000);
	make_inst(i++, INST_SUB, 3, 3, -10);
	make_inst(i++, INST_CMP, 1, 2, 0);
	make_inst(i++, INST_IFGT, 0, 0, 10);
	make_inst(i++, INST_NOP, 0, 0, 0);
	make_inst(i++, INST_NOP, 0, 0, 0);
	make_inst(i++, INST_NOP, 0, 0, 0);
	make_inst(i++, INST_ADD, 1, 3, 0);
	
	make_inst(i++, INST_JUMP, 0, 0, 3);
	make_inst(i++, INST_SYSC, 1, 0, SYSC_PUTI);
	make_inst(i++, INST_SYSC, 0, 0, SYSC_EXIT);

	make_inst(i, INST_HALT, 0, 0, 0);*/
	
	make_inst(i++, INST_SUB, 2, 2, -1000); /* R2 -= R2-1000 */
	make_inst(i++, INST_ADD, 1, 2, 500);   /* R1 += R2+500 */
	make_inst(i++, INST_SYSC, 1, 0, SYSC_NEW_THREAD);	
	make_inst(i++, INST_SYSC, 5, 0, SYSC_SLEEP);
	make_inst(i++, INST_ADD, 0, 2, 200);   /* R0 += R2+200 */
	make_inst(i++, INST_ADD, 0, 1, 100);   /* R0 += R1+100 */
	make_inst(i++, INST_SYSC, 1, 0, SYSC_PUTI);
	make_inst(i++, INST_SYSC, 0, 0, SYSC_EXIT);
	
	/*** valeur initiale du PSW ***/
	memset (&process[current_process].cpu, 0, sizeof(process[current_process].cpu));
	process[current_process].cpu.PC = 0;
	process[current_process].cpu.SB = 0;
	process[current_process].cpu.SS = 20;

	return process[current_process].cpu;
}


/**********************************************************
** Simulation du systeme (mode systeme)
***********************************************************/
PSW ordonnanceur(PSW m) {
	process[current_process].cpu = m;
	do {
		current_process = (current_process + 1) % MAX_PROCESS;
		if(process[current_process].state == SLEEP && sleep_time[current_process]<time(&t))
			process[current_process].state = READY;
	} while (process[current_process].state != READY);
	printf("current process: %d\n", current_process);
	return process[current_process].cpu;
}

PSW new_thread(PSW m) {
	m.PC++;
	int i;
	for(i=0;i<MAX_PROCESS;i++) {
		if(process[i].state == EMPTY) {
			printf("Création nouveau thread %d\n",i);
			process[i].cpu = m;
			process[i].state = READY;
			m.RI.i = i;
			m.AC = i;
			process[i].cpu.RI.i = 0;
			process[i].cpu.AC = 0;
			return process[i].cpu;
		}
	}
	printf("TROP DE PROCESSUS!!!!!!\n");
	return m;
}

PSW sysc_int(PSW m) {
	switch(m.RI.ARG) {
		case SYSC_EXIT:
			printf("SYSC_EXIT\n");
			process[current_process].state = EMPTY;
			int i;
			int vide = 1;
			for(i=0;i<MAX_PROCESS;i++) {
				if(process[i].state == READY) vide = 0;
			}
			if(vide == 1) exit(0);
			m = ordonnanceur(m);
			break;
		case SYSC_PUTI:
			printf("Premier registre : %d.\n",m.DR[m.RI.i]);
			m.PC++;
			break;
		case SYSC_NEW_THREAD:
			m = new_thread(m);
			break;
		case SYSC_SLEEP:
			printf("Processus n°%d endormi %d secondes\n",current_process, m.RI.i);
			process[current_process].state = SLEEP;
			sleep_time[current_process] = time(&t) + m.RI.i;
			m.PC++;
			m = ordonnanceur(m);
			break;
		case SYSC_GETCHAR:
			if(tampon != '\0') m.DR[m.RI.i] = tampon;
			else process[current_process].state = GETCHAR;
			m = ordonnanceur(m);
			break;
		case SYSC_FORK:
			break;
	}
	return m;
}


PSW systeme(PSW m) {
	switch (m.IN) {
		case INT_INIT:
			return (systeme_init());
		case INT_SEGV:
			printf("INT_SEGV\n");
			exit(1);
		case INT_TRACE:
			printf("INT_TRACE (PC: %d  DR: %d %d %d %d %d %d %d %d).\n",m.PC,m.DR[0],m.DR[1],m.DR[2],m.DR[3],m.DR[4],m.DR[5],m.DR[6],m.DR[7]);
			break;
		case INT_INST:
			printf("INT_INST\n");
			exit(1);
		case INT_CLOCK:
			m = ordonnanceur(m);
			break;
		case INT_SYSC:
			m = sysc_int(m);
			break;
	}
	return m;
}
