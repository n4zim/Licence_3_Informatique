
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <time.h>

#include "cpu.h"
#include "systeme.h"

#define MAX_PROCESS  (20)   /* nb maximum de processus  */

#define EMPTY         (0)   /* processus non-pret       */
#define READY         (1)   /* processus pret           */
#define SLEEP 		  (2)   /* processus endormi		*/
#define GETCHAR 	  (3)   /* endormi en attente de caractÃ¨re */

struct {
    PSW  cpu;               /* mot d'etat du processeur */
    int  state;             /* etat du processus        */
    time_t wake_at;
    int mem;
} process[MAX_PROCESS];   /* table des processus      */

int current_process = -1;   /* nu du processus courant  */

char tampon = '\0';       /* le '\0' indique le vide */
int compteur_getchar = 0;


/**********************************************************
** Demarrage du systeme
***********************************************************/

static PSW systeme_init(void) {
	PSW cpu;
	struct process process;
	process[0].state = READY; 
	current_process = 0;

	printf("Booting.\n");
	/*** creation d'un programme ***/
	// make_inst(0, INST_SUB, 2, 2, -1000); /* R2 -= R2-1000 */
	// make_inst(1, INST_ADD, 1, 2, 500);   /* R1 += R2+500 */
	// make_inst(2, INST_ADD, 0, 2, 200);   /* R0 += R2+200 */
	// make_inst(3, INST_ADD, 0, 1, 100);   /* R0 += R1+100 */

	make_inst(0, INST_SUB, 1, 1, 0);
	make_inst(1, INST_SUB, 2, 2, -1000);
	make_inst(2, INST_SUB, 3, 3, -10);
	make_inst(3, INST_CMP, 1, 2, 0);
	make_inst(4, INST_IFGT,0, 0, 10); 
	make_inst(5, INST_SYSC, 1, 0, SYSC_PUTI);
	make_inst(6, INST_NOP, 0, 0, 0);
	make_inst(7, INST_NOP, 0, 0, 0);
	make_inst(8, INST_ADD, 1, 3, 0);
	make_inst(9, INST_JUMP, 0, 0, 3);
	make_inst(10, INST_HALT, 0, 0, 0);
	// make_inst(10, INST_SYSC, 1, 2, 0);
	// make_inst(11, INST_NOP, 0, 0, 0);

	//make_inst(10, INST_HALT, 0, 0, 0);
	//make_inst(12, INST_LOAD, 1, 2, 0);
	
	/*** valeur initiale du PSW ***/
	memset (&cpu, 0, sizeof(cpu));
	cpu.PC = 0;
	cpu.SB = 0;
	cpu.SS = 20;

	return cpu;
}

PSW sysc(PSW m) {

	switch(m.RI.ARG)
	{
		case SYSC_EXIT:
			exit(1);
			break;
		case SYSC_PUTI:
			printf("R%d = %d\n", m.RI.i, m.DR[m.RI.i]);
			break;
		case SYSC_NEW_THREAD :
			m = sysc_new_thread(m);
			break;
		case SYSC_SLEEP:
			m = sysc_sleep(m);
			break;
		case SYSC_GETCHAR:
			m = sysc_getchar(m);
			break;
		case SYSC_FORK:
			m = sysc_fork(m);
			break;
		default : 
			break;
	}

	return m;
}


/**********************************************************
** Simulation du systeme (mode systeme)
***********************************************************/
PSW ordonnanceur(PSW m) {
	if (current_process == -1)  {
		process [0].cpu = m;
		current_process = 0;
	} 
	else {
		process[current_process].cpu = m;
		process[current_process].state = EMPTY;
	}
	do {
		printf("Processus numero : %d\n", current_process);
		current_process = (current_process + 1) % MAX_PROCESS;
		if(process[current_process].state == SLEEP)
		{
			if(time() > process[current_process].wake_at)
				process[current_process].state = READY;
		}
	} while (process[current_process].state != READY);
	
	m = process[current_process].cpu;

	return m;
}

PSW sysc_new_thread (PSW m) {
	int index_fils = (current_process + 1) % MAX_PROCESS;
	process[index_fils].cpu = m;
	process[index_fils].cpu.RI.i = 0;
	process[index_fils].cpu.AC = 0;
	m.RI.i = current_process;
	m.AC = current_process;
	return m;
}

PSW sysc_sleep(PSW m){

    time_t time_tmp = time();
    time_tmp = time_tmp + cpu.RI.i;

    process[current_process].state = SLEEP;
    process[current_process].wake_at = time_tmp;

	return m;
}

PSW sysc_getchar(PSW m){

	if(tampon == '\0')
		process[current_process].state = GETCHAR;
		compteur_getchar += 1;
		m = ordonnanceur(m);
	else
	{
		process[current_process].state = READY;
		m.RI.i = tampon;
		tampon = '\0';
		compteur_getchar -= 1;
	}

	return m;
}

PSW sysc_fork(PSW m){



	return m;
}

PSW systeme(PSW m) {

	interruptNumber(m);
	switch (m.IN) {
		case INT_INIT:
			return (systeme_init());
		case INT_SEGV:
			printf("erreur adressage \n");
			exit(-1);
			break;
		case INT_TRACE:
			systeme_trace(m);
			break;
		case INT_INST:
			printf("erreur instruction inconnue \n");
			exit(-1);
			break;
		case INT_SYSC:
			sysc(m);
			break;
		case INT_CLOCK:
			ordonnanceur(m);
			break;
	}
	return m;
}


void interruptNumber(PSW m){
	return;
	printf("Interruption : %d\n", m.IN);
}

void systeme_trace(PSW m){
	return;
	printf("PC: %d\n", m.PC);
	int i;
	for(i=0; i < 8; i++)
		printf("DR[%d]: %d\n", i, m.DR[i]);
}