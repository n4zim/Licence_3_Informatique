
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <time.h>

#include "cpu.h"
#include "systeme.h"

#define MAX_PROCESS  (20)   /* nb maximum de processus  */

#define EMPTY         (0)   /* processus non-pret       */
#define READY         (1)   /* processus pret           */
#define SLEEP 		  (2)   /* processus endormi		*/
#define GETCHAR 	  (3)   /* endormi en attente de caract√®re */

struct {
    PSW  cpu;               /* mot d'etat du processeur */
    int  state;             /* etat du processus        */
    time_t wake_at;
} process[MAX_PROCESS];   /* table des processus      */

int current_process = -1;   /* nu du processus courant  */

char tampon = '\0';       /* le '\0' indique le vide */
int compteur_getchar = 0;

WORD mem[600];


/**********************************************************
** Demarrage du systeme
***********************************************************/

static PSW systeme_init(void) {
	//PSW cpu;
	current_process = 0;

	int j;
	for(j = 0; j < MAX_PROCESS; j++)
		process[j].state = EMPTY;

	process[0].state = READY; 
	

	printf("Booting.\n");
	/*** creation d'un programme ***/
	// make_inst(0, INST_SUB, 2, 2, -1000); /* R2 -= R2-1000 */
	// make_inst(1, INST_ADD, 1, 2, 500);   /* R1 += R2+500 */
	// make_inst(2, INST_ADD, 0, 2, 200);   /* R0 += R2+200 */
	// make_inst(3, INST_ADD, 0, 1, 100);   /* R0 += R1+100 */

	int i = 0;
	make_inst(i++, INST_SUB, 1, 1, 0);
	//make_inst(i++, INST_SUB, 2, 2, -1000);
	//make_inst(i++, INST_SUB, 3, 3, -10);
	make_inst(i++, INST_SYSC, 0, 0, SYSC_FORK);
	make_inst(i++, INST_SYSC, 3, 0, SYSC_SLEEP);

	//make_inst(i++, INST_CMP, 1, 2, 0);
	//make_inst(i++, INST_IFGT,0, 0, 10); 
	make_inst(i++, INST_SYSC, 1, 0, SYSC_PUTI);
	//make_inst(i++, INST_ADD, 1, 3, 0);
	//make_inst(i++, INST_JUMP, 0, 0, 3);
	make_inst(i++, INT_SYSC, 0, 0, SYSC_EXIT);
	// make_inst(10, INST_SYSC, 1, 2, 0);
	// make_inst(11, INST_NOP, 0, 0, 0);

	//make_inst(10, INST_HALT, 0, 0, 0);
	//make_inst(12, INST_LOAD, 1, 2, 0);
	
	/*** valeur initiale du PSW ***/
	memset (&process[current_process].cpu, 0, sizeof(process[current_process].cpu));
	process[current_process].cpu.PC = 0;
	process[current_process].cpu.SB = 0;
	process[current_process].cpu.SS = 20;

	return process[current_process].cpu;
}

PSW sysc(PSW m) {

	switch(m.RI.ARG)
	{
		case SYSC_EXIT:
			process[current_process].state = EMPTY;

			int i;
			int fin = 1;
			for(i = 0; i < MAX_PROCESS; i++)
			{
				if(process[i].state == READY)
					fin = 0;
			}
			if(fin)
				exit(1);

			m = ordonnanceur(m);
			break;
		case SYSC_PUTI:
			printf("R%d = %d\n", m.RI.i, m.DR[m.RI.i]);
			m.PC += 1;
			break;
		case SYSC_NEW_THREAD :
			m.PC += 1;
			m = sysc_new_thread(m);
			break;
		case SYSC_SLEEP:
			m = sysc_sleep(m);
			m.PC += 1;
			m = ordonnanceur(m);
			break;
		case SYSC_GETCHAR:
			m = sysc_getchar(m);
			m.PC += 1;
			m = ordonnanceur(m);
			break;
		case SYSC_FORK:
			m.PC += 1;
			m = sysc_fork(m);
			break;
		default : 
			break;
	}

	return m;
}


/**********************************************************
** Simulation du systeme (mode systeme)
***********************************************************/
PSW ordonnanceur(PSW m) {

	process[current_process].cpu = m;
	do {
		current_process = (current_process + 1) % MAX_PROCESS;
		if(process[current_process].state == SLEEP)
		{
			if(time(NULL) >= process[current_process].wake_at)
				process[current_process].state = READY;
		}
	} while (process[current_process].state != READY);
	
	printf("Processus numero : %d\n", current_process);
	m = process[current_process].cpu;

	return m;
}

PSW sysc_new_thread (PSW m) {

	int i;
	for(i = 0; i < MAX_PROCESS; i++)
	{
		if(process[i].state == EMPTY)
		{
			process[i].cpu = m;
			process[i].state = READY;
			process[i].cpu.RI.i = 0;
			process[i].cpu.AC = 0;
			m.RI.i = i;
			m.AC = i;

			return process[i].cpu;
		}
	}
	
	return m;
}

PSW sysc_sleep(PSW m){
    time_t time_tmp = time(NULL);
    time_tmp = time_tmp + m.RI.i;

    process[current_process].state = SLEEP;
    process[current_process].wake_at = time_tmp;

	return m;
}

PSW sysc_getchar(PSW m){

	if(tampon == '\0')
	{
		process[current_process].state = GETCHAR;
		compteur_getchar += 1;
		m = ordonnanceur(m);
	}
	else
	{
		process[current_process].state = READY;
		m.RI.i = tampon;
		tampon = '\0';
		compteur_getchar -= 1;
	}

	return m;
}

PSW sysc_fork(PSW m){

	int i;
	for(i = 0; i < MAX_PROCESS; i++)
	{
		if(process[i].state == EMPTY)
		{
			process[i].cpu = m;
			process[i].state = READY;
			process[i].cpu.RI.i = 0;
			process[i].cpu.AC = 0;
			process[i].cpu.SB = 30*i;
			m.RI.i = i;
			m.AC = i;

			int j;
			for(j = 0; j < 30; j++)
			{
				mem[(i*30) + j] = mem[(current_process*30) + j];
			}

			return process[i].cpu;
		}
	}
	
	return m;
}

PSW systeme(PSW m) {

	interruptNumber(m);
	switch (m.IN) {
		case INT_INIT:
			return (systeme_init());
		case INT_SEGV:
			printf("erreur adressage\n");
			exit(-1);
			break;
		case INT_TRACE:
			systeme_trace(m);
			break;
		case INT_INST:
			printf("erreur instruction inconnue \n");
			exit(-1);
			break;
		case INT_SYSC:
			m= sysc(m);
			break;
		case INT_CLOCK:
			m = ordonnanceur(m);
			break;
	}
	return m;
}


void interruptNumber(PSW m){
	return;
	printf("Interruption : %d\n", m.IN);
}

void systeme_trace(PSW m){
	return;
	printf("PC: %d\n", m.PC);
	int i;
	for(i=0; i < 8; i++)
		printf("DR[%d]: %d\n", i, m.DR[i]);
}