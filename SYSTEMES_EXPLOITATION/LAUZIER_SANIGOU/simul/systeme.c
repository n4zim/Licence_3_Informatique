
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#include "cpu.h"
#include "systeme.h"

#define MAX_PROCESS  (20)   /* nb maximum de processus  */

#define EMPTY         (0)   /* processus non-pret       */
#define READY         (1)   /* processus pret           */

struct {
    PSW  cpu;               /* mot d'etat du processeur */
    int  state;             /* etat du processus        */
    }
    process[MAX_PROCESS];   /* table des processus      */

int current_process = -1;   /* nu du processus courant  */


/**********************************************************
** Demarrage du systeme
***********************************************************/

static PSW systeme_init(void) {
	PSW cpu;
	struct process process;
	process[0].state = READY; 
	current_process = 0;

	printf("Booting.\n");
	/*** creation d'un programme ***/
	// make_inst(0, INST_SUB, 2, 2, -1000); /* R2 -= R2-1000 */
	// make_inst(1, INST_ADD, 1, 2, 500);   /* R1 += R2+500 */
	// make_inst(2, INST_ADD, 0, 2, 200);   /* R0 += R2+200 */
	// make_inst(3, INST_ADD, 0, 1, 100);   /* R0 += R1+100 */

	make_inst(0, INST_SUB, 1, 1, 0);
	make_inst(1, INST_SUB, 2, 2, -1000);
	make_inst(2, INST_SUB, 3, 3, -10);
	make_inst(3, INST_CMP, 1, 2, 0);
	make_inst(4, INST_IFGT,0, 0, 10); 
	make_inst(5, INST_SYSC, 1, 0, SYSC_PUTI);
	make_inst(6, INST_NOP, 0, 0, 0);
	make_inst(7, INST_NOP, 0, 0, 0);
	make_inst(8, INST_ADD, 1, 3, 0);
	make_inst(9, INST_JUMP, 0, 0, 3);
	make_inst(10, INST_HALT, 0, 0, 0);
	// make_inst(10, INST_SYSC, 1, 2, 0);
	// make_inst(11, INST_NOP, 0, 0, 0);

	//make_inst(10, INST_HALT, 0, 0, 0);
	//make_inst(12, INST_LOAD, 1, 2, 0);
	
	/*** valeur initiale du PSW ***/
	memset (&cpu, 0, sizeof(cpu));
	cpu.PC = 0;
	cpu.SB = 0;
	cpu.SS = 20;

	return cpu;
}

PSW sysc(PSW m) {

	switch(m.RI.ARG)
	{
		case SYSC_EXIT:
			exit(1);
			break;
		case SYSC_PUTI:
			printf("R%d = %d\n", m.RI.i, m.DR[m.RI.i]);
			break;
	}

	return m;
}


/**********************************************************
** Simulation du systeme (mode systeme)
***********************************************************/

PSW systeme(PSW m) {

	interruptNumber(m);
	switch (m.IN) {
		case INT_INIT:
			return (systeme_init());
		case INT_SEGV:
			printf("erreur adressage \n");
			exit(-1);
			break;
		case INT_TRACE:
			systeme_trace(m);
			break;
		case INT_INST:
			printf("erreur instruction inconnue \n");
			exit(-1);
			break;
		case INT_SYSC:
			sysc(m);
			break;
		case INT_CLOCK:
			process[current_process].cpu = m;
			process[current_process].state = EMPTY;
			do {
				current_process = (current_process + 1) % MAX_PROCESS;
			} while (process[current_process].state != READY);
			process[current_process].state = READY;
			break;
	}
	return m;
}


void interruptNumber(PSW m){
	return;
	printf("Interruption : %d\n", m.IN);
}

void systeme_trace(PSW m){
	return;
	printf("PC: %d\n", m.PC);
	int i;
	for(i=0; i < 8; i++)
		printf("DR[%d]: %d\n", i, m.DR[i]);
}