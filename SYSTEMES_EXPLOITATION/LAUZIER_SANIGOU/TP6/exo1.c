#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <unistd.h>

pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
pthread_cond_t condition = PTHREAD_COND_INITIALIZER;
volatile int eR1 = 1;
volatile int eR2 = 0;

void* travail(void* _num){
    int ressource;
    
    /* attendre mon tour */
    
    pthread_mutex_lock(&mutex);
    while (!eR1 && !eR2) {
        /* je m'endors car la condition est fausse 
           et je libère mutex en une seule opération atomique */
        pthread_cond_wait(&condition, &mutex);
        /* je suis réveillé et j'ai repris mutex */ 
    }
    /* section critique begin */
    if(eR1) {
    	eR1 = 0;
    	ressource = 1; 
    } else {
    	eR2 = 0;
    	ressource = 2;
    }

   /* section critique end */

    pthread_mutex_unlock(&mutex);

    printf("La ressource %d est utilisée par le thread n°%d\n", ressource, _num);
    sleep(1);
    /* modifier tour et réveiller les autres */
    
    pthread_mutex_lock(&mutex);

    /* Liberation des ressources avant d'annoncer le changement */  
    if(ressource == 1)
    	eR1 = 1;
    else
    	eR2 = 1;
 
    pthread_cond_broadcast(&condition);
    pthread_mutex_unlock(&mutex);

    return NULL;
}

int testTravail(void){
	pthread_t filsA, filsB, filsC, filsD;

	if (pthread_create(&filsA, NULL, travail, (int*)1 )) perror("thread");
    if (pthread_create(&filsB, NULL, travail, (int*)2 )) perror("thread");
    if (pthread_create(&filsC, NULL, travail, (int*)3 )) perror("thread");
    if (pthread_create(&filsD, NULL, travail, (int*)4 )) perror("thread");

    if (pthread_join(filsA, NULL)) perror("pthread_join");
    if (pthread_join(filsB, NULL)) perror("pthread_join");
    if (pthread_join(filsC, NULL)) perror("pthread_join");
    if (pthread_join(filsD, NULL)) perror("pthread_join");



	return (EXIT_SUCCESS);
}

#define NB_FOUR (4)

volatile int FOUR[NB_FOUR];

void* philo(void * _phil){
    long phil = (long) _phil;
    long num_gauche = phil;
    long num_droit;
   
    num_droit = (phil+1) % NB_FOUR;
    /* attendre mon tour */
    
    pthread_mutex_lock(&mutex);
    while (!(FOUR[num_gauche] && FOUR[num_droit])) {
        /* je m'endors car la condition est fausse 
           et je libère mutex en une seule opération atomique */
        pthread_cond_wait(&condition, &mutex);
        /* je suis réveillé et j'ai repris mutex */ 
    }
    /* section critique begin */
  	FOUR[num_gauche] = 0;
  	FOUR[num_droit] = 0;

   /* section critique end */

    pthread_mutex_unlock(&mutex);

    printf("Le philosophe %d utilise les fourchettes (%d et %d)\n", phil, num_gauche, num_droit);
    printf("Le philosophe %d mange\n", phil);
    sleep(1);
    /* modifier tour et réveiller les autres */
    
    pthread_mutex_lock(&mutex);

    /* Liberation des ressources avant d'annoncer le changement */  


 	 printf("Le philosophe %d repose les fourchettes\n", phil);

 	FOUR[num_gauche] = 1;
 	FOUR[num_droit] = 1;
 	 printf("Le philosophe %d pense\n", phil);
    pthread_cond_broadcast(&condition);
    pthread_mutex_unlock(&mutex);

    return NULL;
}

int main(){
	pthread_t fils[NB_FOUR];

	int j;
	// initialisation tableau toute les fourchettes sont libres
	for(j = 0; j < NB_FOUR; j++){
		FOUR[j] = 1;
	}

	long i;
	for(i = 0; i < NB_FOUR; i++){
		if (pthread_create(&fils[i], NULL, philo, (void*) i )) perror("thread");
	}

	for(i = 0; i < NB_FOUR; i++)
		if (pthread_join(fils[i], NULL)) perror("pthread_join");


	return (EXIT_SUCCESS);
}

